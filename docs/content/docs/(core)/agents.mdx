---
title: Agents
description: Multi-agent setup with isolated workspaces, databases, and identities.
---

# Agents

Spacebot supports multiple agents running on a single instance. Each agent is an independent entity with its own soul, memory, conversations, and messaging bindings. One binary, multiple personalities.

## Why Agents

A single Spacebot instance might serve different purposes — a personal assistant, a dev helper, a community bot. Each needs its own identity, its own memory graph, its own conversation history. Mixing them in one database with an `agent_id` column on every row is the wrong abstraction. These are separate worlds that happen to share infrastructure.

## What An Agent Is

An agent is a self-contained unit. It has:

- **A workspace** — directory containing identity files (SOUL.md, IDENTITY.md, USER.md) and optional prompt overrides
- **Its own databases** — SQLite, LanceDB, and redb, completely isolated from other agents
- **Its own cortex** — monitoring its own processes and memory graph
- **Its own conversations** — channels, branches, workers scoped to this agent
- **Messaging bindings** — which Discord guilds, Telegram chats, or webhook endpoints route to this agent

An agent does NOT have its own LLM provider credentials, its own binary, or its own process. All agents share the same Spacebot process, the same tokio runtime, and the same API keys. Isolation is at the data level, not the process level.

## On-Disk Structure

```
~/.spacebot/                              # instance root (SPACEBOT_DIR env override)
├── config.toml                           # instance config
│
├── agents/
│   ├── main/                             # default agent
│   │   ├── workspace/
│   │   │   ├── SOUL.md                   # personality, values, boundaries
│   │   │   ├── IDENTITY.md               # name, nature, vibe
│   │   │   └── USER.md                   # info about the human
│   │   ├── data/
│   │   │   ├── spacebot.db              # SQLite (memories, conversations, cron jobs)
│   │   │   ├── lancedb/                 # LanceDB (embeddings, FTS)
│   │   │   └── config.redb             # redb (agent-level settings, secrets)
│   │   └── archives/                    # compaction transcripts
│   │
│   └── dev-bot/                          # second agent
│       ├── workspace/

```

Identity files are per-agent. System prompts (CHANNEL.md, BRANCH.md, etc.) are shared across all agents by default — they define process behavior, not personality. An agent can override any prompt by placing a file with the same name in its `workspace/prompts/` directory.

## Configuration

### Instance Config

`~/.spacebot/config.toml`:

```toml
# LLM provider credentials (instance-level, shared by all agents)
[llm]
anthropic_key = "env:ANTHROPIC_API_KEY"
openai_key = "env:OPENAI_API_KEY"

# Defaults for all agents (overridable per-agent)
[defaults]
channel_model = "anthropic/claude-sonnet-4-20250514"
worker_model = "anthropic/claude-sonnet-4-20250514"
cortex_model = "anthropic/claude-sonnet-4-20250514"
max_concurrent_branches = 5
max_turns = 5
context_window = 128000

[defaults.compaction]
background_threshold = 0.80
aggressive_threshold = 0.85
emergency_threshold = 0.95

[defaults.cortex]
tick_interval_secs = 30
worker_timeout_secs = 300
branch_timeout_secs = 60

# Agent definitions
[[agents]]
id = "main"
default = true

[[agents]]
id = "dev-bot"
channel_model = "anthropic/claude-sonnet-4-20250514"

# Messaging platform credentials (instance-level)
[messaging.discord]
enabled = true
token = "env:DISCORD_BOT_TOKEN"

[messaging.webhook]
enabled = true
port = 18789
bind = "127.0.0.1"

# Route messaging channels to agents
[[bindings]]
agent_id = "main"
channel = "discord"
guild_id = "123456789"

[[bindings]]
agent_id = "dev-bot"
channel = "discord"
guild_id = "987654321"

[[bindings]]
agent_id = "main"
channel = "webhook"
```

The `env:` prefix on credential values reads from environment variables at startup. Credentials are never stored in plaintext — they're either env references or encrypted in redb via the secrets system.

### What's Instance-Level vs Agent-Level

| Setting                  | Level    | Notes                                 |
| ------------------------ | -------- | ------------------------------------- |
| LLM API keys             | Instance | Shared credentials for all agents     |
| Messaging credentials    | Instance | One Discord bot token for all agents  |
| Messaging bindings       | Instance | Routes conversations to agents        |
| Default model/thresholds | Instance | Defaults that agents inherit          |
| Channel model            | Agent    | Which model this agent's channels use |
| Worker model             | Agent    | Which model this agent's workers use  |
| Compaction thresholds    | Agent    | Override defaults if needed           |
| Cortex config            | Agent    | Tick interval, timeouts               |
| Identity (SOUL, USER)    | Agent    | Unique per agent                      |
| Memories                 | Agent    | Completely isolated databases         |
| Conversations            | Agent    | Completely isolated                   |
| Settings/secrets         | Agent    | Per-agent redb                        |

### Agent Config Resolution

Agent settings resolve as: **agent override > instance defaults > hardcoded defaults**.

```rust
pub struct ResolvedAgentConfig {
    pub id: String,
    pub workspace: PathBuf,
    pub data_dir: PathBuf,
    pub channel_model: String,
    pub worker_model: String,
    pub cortex_model: String,
    pub compaction: CompactionConfig,
    pub channel: ChannelConfig,
    pub cortex: CortexConfig,
}

impl AgentConfig {
    pub fn resolve(&self, defaults: &DefaultsConfig) -> ResolvedAgentConfig {
        ResolvedAgentConfig {
            id: self.id.clone(),
            workspace: self.workspace(),
            data_dir: self.data_dir(),
            channel_model: self.channel_model
                .clone()
                .unwrap_or_else(|| defaults.channel_model.clone()),
            // ... etc
        }
    }
}
```

## Agent IDs

Agent IDs are lowercase alphanumeric with hyphens. Normalized on creation. Must be unique within the instance.

Valid: `main`, `dev-bot`, `research-assistant`
Invalid: `My Bot`, `agent@1`, `MAIN`

The default agent is whichever entry has `default = true`. If no default is specified, the first agent in the list is the default. There must always be at least one agent.

## Messaging Routing

When a message arrives from a messaging platform, the router determines which agent handles it:

1. Check the `bindings` table for a match on `channel` + platform-specific fields (guild_id, chat_id, etc.)
2. If matched, route to that agent
3. If no match, route to the default agent

Bindings are specific — a Discord guild ID maps to exactly one agent. Two agents cannot be bound to the same guild. DMs are routed to the default agent unless a binding explicitly maps a user.

### Conversation ID Scoping

Conversation IDs are scoped to agents: `{agent_id}:{platform}:{platform_id}`. This ensures uniqueness even if two agents somehow see the same platform entity.

```
main:discord:123:456
dev-bot:discord:987:654
main:webhook:github-ci
```

## The Agent Struct

In code, an `Agent` bundles everything needed to run independently:

```rust
pub struct Agent {
    pub id: String,
    pub config: ResolvedAgentConfig,
    pub db: Db,
    pub memory_search: Arc<MemorySearch>,
    pub llm_manager: Arc<LlmManager>,
    pub cortex: Cortex,
    pub prompts: Prompts,
    pub identity: Identity,
    pub event_tx: mpsc::Sender<ProcessEvent>,
}
```

`LlmManager` is shared across agents (same API keys, same provider clients). Everything else is per-agent.

## Startup Flow

```
1. Load config.toml
2. Initialize LLM manager (shared)
3. Initialize messaging adapters (shared, based on [messaging.*] config)
4. For each agent in config:
   a. Resolve agent config (merge with defaults)
   b. Ensure workspace directory exists (create + bootstrap if new)
   c. Connect databases (agent's data_dir)
   d. Initialize memory system (agent's SQLite + LanceDB)
   e. Load identity files (agent's workspace)
   f. Load prompts (agent workspace overrides, then shared prompts)
   g. Create agent's event bus (mpsc channel)
   h. Start agent's cortex
   i. Register agent in the router
5. Start messaging adapters (MessagingManager.start())
6. Run event loop: route inbound messages to agents via bindings
```

If an agent's databases don't exist, they're created and migrations run. If its workspace doesn't exist, it's created with template identity files.

## Agent Lifecycle

### Creation

```bash
spacebot agents create dev-bot
```

Or via config: add an `[[agents]]` entry to config.toml and restart. On next startup, the directories and databases are bootstrapped.

Creation does:

1. Validate ID (lowercase alphanumeric + hyphens, unique)
2. Create `agents/{id}/workspace/` with default identity files:
   - `SOUL.md` seeded with the Spacebot voice/personality baseline
   - `IDENTITY.md` seeded with a short starter identity profile
   - `USER.md` scaffolded as an editable template
3. Create `agents/{id}/data/` with empty databases
4. Add entry to config.toml

### Deletion

```bash
spacebot agents delete dev-bot
```

Deletion does:

1. Stop the agent's cortex and drain in-flight work
2. Remove bindings referencing this agent
3. Optionally trash the agent's directories (workspace, data, archives)
4. Remove the config entry

Deletion of the default agent is rejected.

## Prompt Resolution

System prompts load with a fallback chain:

```
agent workspace/prompts/CHANNEL.md   →  found? use it
         ↓ not found
shared prompts/CHANNEL.md            →  found? use it
         ↓ not found
error: missing prompt
```

This lets agents customize behavior without copying every prompt file. Most agents will use the shared defaults. An agent that needs different channel behavior (more aggressive delegation, different tool usage patterns) can override just CHANNEL.md.

Identity files (SOUL.md, IDENTITY.md, USER.md) always load from the agent's workspace. There is no shared fallback — every agent must have its own identity.

## Cortex Per Agent

Each agent runs its own cortex. The cortex monitors that agent's workers, branches, channels, and memory graph. It has no awareness of other agents.

Cross-agent coordination (one agent spawning work on another, shared observations, identity coherence across agents) is a future concern. For now, agents are islands.

## What OpenClaw Does Differently

OpenClaw uses a single JSON5 config file with all agents defined inline. File-based workspaces with markdown memory files. A shared gateway process with WebSocket RPC for agent management. Bindings route platform channels to agents.

Spacebot takes the same conceptual model but adapts it:

| Concern            | OpenClaw                      | Spacebot                                      |
| ------------------ | ----------------------------- | --------------------------------------------- |
| Config format      | JSON5                         | TOML                                          |
| Memory storage     | Markdown files + SQLite index | SQLite + LanceDB (per agent)                  |
| Database isolation | File-based (separate dirs)    | Database-level (separate SQLite/LanceDB/redb) |
| Agent management   | WebSocket RPC + CLI           | CLI + config file                             |
| Cortex             | N/A                           | Per-agent cortex                              |
| Identity files     | Same set                      | Same set (SOUL, IDENTITY, USER)               |
| Prompt overrides   | Skills system                 | Per-agent prompt directory                    |
| Bindings           | Config array with match rules | Config array with platform filters            |
| Subagent spawning  | Cross-agent tool calls        | Future concern                                |

## CLI Commands

```bash
# List configured agents
spacebot agents list

# Create a new agent (interactive)
spacebot agents create

# Create a new agent (non-interactive)
spacebot agents create dev-bot --model anthropic/claude-sonnet-4-20250514

# Delete an agent
spacebot agents delete dev-bot

# Run a one-shot message on a specific agent
spacebot run --agent dev-bot --message "what's your name?"

# Default agent (no --agent flag needed)
spacebot run --message "hello"
```

## Future Considerations

- **Cross-agent communication** — one agent spawning work on another agent, or sending messages to another agent's conversation. Requires a routing layer between agents.
- **System-level supervisor** — a process that monitors all agents (restarts crashed agents, tracks resource usage). Distinct from the per-agent cortex.
- **Agent templates** — pre-built agent configurations for common use cases (dev assistant, research bot, community manager).
- **Hot reload agent topology** — adding/removing agents without restarting the process. Currently requires restart. (Config values, prompts, identity, and skills already hot-reload — see [Configuration](/docs/config).)
- **Agent-level secrets** — per-agent API keys for third-party services (separate from instance-level LLM keys).

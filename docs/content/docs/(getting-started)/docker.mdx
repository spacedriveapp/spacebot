---
title: Docker
description: Run Spacebot in a container with slim or full image variants.
---

# Docker

Run Spacebot in a container. Two image variants: `slim` (no browser) and `full` (includes Chromium for browser workers).

## Quick Start

```bash
docker run -d \
  --name spacebot \
  -e ANTHROPIC_API_KEY="sk-ant-..." \
  -v spacebot-data:/data \
  -p 19898:19898 \
  ghcr.io/spacedriveapp/spacebot:slim
```

The web UI is available at `http://localhost:19898`.

## Image Variants

### `spacebot:slim`

Minimal runtime. Everything works except the browser tool.

- Base: `debian:bookworm-slim`
- Size: ~150MB
- Includes: Spacebot binary, CA certs, SQLite libs, bubblewrap (process sandbox), embedded frontend

### `spacebot:full`

Includes Chromium for browser workers (headless Chrome automation via CDP).

- Base: `debian:bookworm-slim` + Chromium
- Size: ~800MB
- Includes: everything in slim + Chromium + browser dependencies

## Data Volume

All persistent data lives at `/data` inside the container. Mount a volume here.

```
/data/
├── config.toml              # optional, can use env vars instead
├── embedding_cache/         # FastEmbed model cache (~100MB, downloaded on first run)
├── agents/
│   └── main/
│       ├── workspace/       # identity files (SOUL.md, IDENTITY.md, USER.md)
│       ├── data/            # SQLite, LanceDB, redb databases
│       └── archives/        # compaction transcripts
└── logs/                    # log files (daily rotation)
```

On first launch with no config, Spacebot creates a default `main` agent with template identity files. The FastEmbed model (~100MB) downloads on first memory operation -- subsequent starts use the cache.

## Configuration

### Environment Variables

The simplest approach. No config file needed.

```bash
docker run -d \
  --name spacebot \
  -e ANTHROPIC_API_KEY="sk-ant-..." \
  -e DISCORD_BOT_TOKEN="..." \
  -v spacebot-data:/data \
  -p 19898:19898 \
  ghcr.io/spacedriveapp/spacebot:slim
```

Available environment variables:

| Variable                 | Description            |
| ------------------------ | ---------------------- |
| `ANTHROPIC_API_KEY`      | Anthropic API key      |
| `OPENAI_API_KEY`         | OpenAI API key         |
| `OPENROUTER_API_KEY`     | OpenRouter API key     |
| `DISCORD_BOT_TOKEN`      | Discord bot token      |
| `SLACK_BOT_TOKEN`        | Slack bot token        |
| `SLACK_APP_TOKEN`        | Slack app token        |
| `BRAVE_SEARCH_API_KEY`   | Brave Search API key   |
| `SPACEBOT_CHANNEL_MODEL` | Override channel model |
| `SPACEBOT_WORKER_MODEL`  | Override worker model  |

### Config File

Mount a config file into the volume for full control:

```bash
docker run -d \
  --name spacebot \
  -v spacebot-data:/data \
  -v ./config.toml:/data/config.toml:ro \
  -p 19898:19898 \
  ghcr.io/spacedriveapp/spacebot:slim
```

Config values can reference environment variables with `env:VAR_NAME`:

```toml
[llm]
anthropic_key = "env:ANTHROPIC_API_KEY"
```

See [Configuration](/docs/config) for the full config reference.

## Docker Compose

```yaml
services:
  spacebot:
    image: ghcr.io/spacedriveapp/spacebot:slim
    container_name: spacebot
    restart: unless-stopped
    ports:
      - "19898:19898"
    volumes:
      - spacebot-data:/data
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      # Optional:
      # - DISCORD_BOT_TOKEN=${DISCORD_BOT_TOKEN}

volumes:
  spacebot-data:
```

### With Browser Workers

```yaml
services:
  spacebot:
    image: ghcr.io/spacedriveapp/spacebot:full
    container_name: spacebot
    restart: unless-stopped
    ports:
      - "19898:19898"
    volumes:
      - spacebot-data:/data
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    # Chromium needs these for headless operation
    security_opt:
      - seccomp=unconfined
    shm_size: 1gb

volumes:
  spacebot-data:
```

The `shm_size` and `seccomp` settings are needed for Chromium to run properly in a container.

## Building the Image

From the spacebot repo root:

```bash
# Slim (no browser)
docker build --target slim -t spacebot:slim .

# Full (with Chromium)
docker build --target full -t spacebot:full .
```

The multi-stage Dockerfile:

1. **Builder stage** -- Rust toolchain + Bun. Compiles the React frontend, then builds the Rust binary with the frontend embedded.
2. **Slim stage** -- Minimal Debian runtime with the compiled binary.
3. **Full stage** -- Slim + Chromium and its dependencies.

Build time is ~5-10 minutes on first build (downloading and compiling Rust dependencies). Subsequent builds use the cargo cache.

## Ports

| Port  | Service                                 |
| ----- | --------------------------------------- |
| 19898 | HTTP API + Web UI                       |
| 18789 | Webhook receiver (if enabled in config) |

The API server binds to `0.0.0.0` inside the container (overriding the default `127.0.0.1` bind). The webhook port is only needed if you enable the webhook messaging adapter.

## Health Check

The API server responds to `GET /api/health`. Use this for container health checks:

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:19898/api/health"]
  interval: 30s
  timeout: 5s
  retries: 3
```

## Container Behavior

- Spacebot runs in **foreground mode** (`--foreground`) inside the container. No daemonization.
- Logs go to stdout/stderr. Use `docker logs` to view them.
- Graceful shutdown on `SIGTERM` (what `docker stop` sends). Drains active channels, closes database connections.
- The PID file and Unix socket (used in daemon mode) are not created.

## Updates

Spacebot checks for new releases on startup and every hour. When a new version is available, a banner appears in the web UI.

### Manual Update

```bash
docker pull ghcr.io/spacedriveapp/spacebot:slim
docker compose up -d
```

### One-Click Update

Mount the container runtime socket to enable updating directly from the web UI.
For Docker, mount `/var/run/docker.sock`. For Podman, see the [Podman](#podman) section below.

```yaml
services:
  spacebot:
    image: ghcr.io/spacedriveapp/spacebot:slim
    container_name: spacebot
    restart: unless-stopped
    ports:
      - "19898:19898"
    volumes:
      - spacebot-data:/data
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
```

When the socket is mounted, the update banner shows an **Update now** button that pulls the new image and recreates the container automatically. Your `/data` volume is preserved across updates.

Without the socket mount, the banner still notifies you of new versions but you'll need to update manually.

### Update API

You can also check for and trigger updates programmatically:

```bash
# Check for updates
curl http://localhost:19898/api/update/check

# Force a fresh check
curl -X POST http://localhost:19898/api/update/check

# Apply update (requires Docker socket)
curl -X POST http://localhost:19898/api/update/apply
```

## CI / Releases

Images are built and pushed to `ghcr.io/spacedriveapp/spacebot` via GitHub Actions (`.github/workflows/release.yml`).

**Triggers:**

- Push a `v*` tag (e.g. `git tag v0.1.0 && git push --tags`)
- Manual dispatch from the Actions tab

**Tags pushed per release:**

| Tag           | Description              |
| ------------- | ------------------------ |
| `v0.1.0-slim` | Versioned slim           |
| `v0.1.0-full` | Versioned full           |
| `slim`        | Rolling slim             |
| `full`        | Rolling full             |
| `latest`      | Rolling (points to full) |

```bash
# Manual single-instance deploy
fly launch --image ghcr.io/spacedriveapp/spacebot:slim
fly volumes create spacebot_data --size 5
fly secrets set ANTHROPIC_API_KEY="sk-ant-..."
fly deploy
```

## Podman

Spacebot works with Podman as a drop-in replacement for Docker. Set
`SPACEBOT_DEPLOYMENT=docker` (the same value used for Docker) and mount the
Podman socket to enable one-click updates from the web UI.

### Quick Start

```bash
podman run -d \
  --name spacebot \
  -e ANTHROPIC_API_KEY="sk-ant-..." \
  -e SPACEBOT_DEPLOYMENT=docker \
  -v spacebot-data:/data \
  -p 19898:19898 \
  ghcr.io/spacedriveapp/spacebot:slim
```

### One-Click Updates with Podman

Spacebot supports both rootful and rootless Podman socket paths.

**Rootful Podman** — start the socket service and mount it:

```bash
sudo systemctl enable --now podman.socket
```

```bash
podman run -d \
  --name spacebot \
  -e ANTHROPIC_API_KEY="sk-ant-..." \
  -e SPACEBOT_DEPLOYMENT=docker \
  -v spacebot-data:/data \
  -v /run/podman/podman.sock:/run/podman/podman.sock \
  --security-opt label=disable \
  -p 19898:19898 \
  ghcr.io/spacedriveapp/spacebot:slim
```

**Rootless Podman** — enable the user socket and map it to the standard rootful
path inside the container. The container has no user profile, so mapping to
`/run/podman/podman.sock` (not the host's user-scoped path) is cleaner and
requires no extra environment variables:

```bash
systemctl --user enable --now podman.socket
```

```bash
podman run -d \
  --name spacebot \
  -e ANTHROPIC_API_KEY="sk-ant-..." \
  -e SPACEBOT_DEPLOYMENT=docker \
  -v spacebot-data:/data \
  -v $XDG_RUNTIME_DIR/podman/podman.sock:/run/podman/podman.sock \
  --security-opt label=disable \
  -p 19898:19898 \
  ghcr.io/spacedriveapp/spacebot:slim
```

You can also set `DOCKER_HOST=unix:///path/to/podman.sock` to point Spacebot at
any custom socket location.

> **SELinux note (Fedora, RHEL, and derivatives):** SELinux blocks containers
> from connecting to the Podman socket by default. Add
> `--security-opt label=disable` to the `podman run` command, or
> `security_opt: [label=disable]` in your `podman-compose.yml`, when mounting
> the socket.

### Podman Compose

For rootful Podman, use the system socket directly:

```yaml
services:
  spacebot:
    image: ghcr.io/spacedriveapp/spacebot:slim
    container_name: spacebot
    restart: unless-stopped
    ports:
      - "19898:19898"
    volumes:
      - spacebot-data:/data
      - /run/podman/podman.sock:/run/podman/podman.sock
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - SPACEBOT_DEPLOYMENT=docker
    security_opt:
      - label=disable

volumes:
  spacebot-data:
```

For rootless Podman, map the user socket to the standard rootful path inside
the container (no `XDG_RUNTIME_DIR` needed inside the container):

```yaml
services:
  spacebot:
    image: ghcr.io/spacedriveapp/spacebot:slim
    container_name: spacebot
    restart: unless-stopped
    ports:
      - "19898:19898"
    volumes:
      - spacebot-data:/data
      - ${XDG_RUNTIME_DIR}/podman/podman.sock:/run/podman/podman.sock
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - SPACEBOT_DEPLOYMENT=docker
    security_opt:
      - label=disable

volumes:
  spacebot-data:
```

Run with `podman-compose up -d`.

> **Note:** `SPACEBOT_DEPLOYMENT=docker` is required regardless of whether you
> use Docker or Podman — the value tells Spacebot that it is running inside a
> container and can manage its own lifecycle via the socket.
